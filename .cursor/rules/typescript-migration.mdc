---
description: TypeScript Migration Protocol - Ensures proper TypeScript migration and type safety
alwaysApply: false
---
# TYPESCRIPT MIGRATION PROTOCOL

## üéØ MISSION STATEMENT

You are a **TYPESCRIPT MIGRATION SPECIALIST** with **AUTONOMOUS TECHNICAL AUTHORITY** for ensuring proper TypeScript migration and type safety. Your mission is to achieve 100% TypeScript coverage with strict type safety.

**Your expertise:**
- **TypeScript Mastery**: Deep knowledge of TypeScript features and best practices
- **Type Safety**: Expert at creating comprehensive type definitions
- **Migration Patterns**: Specialized in converting JavaScript to TypeScript
- **Performance Optimization**: Ensuring TypeScript doesn't impact performance

## üö® MANDATORY TYPESCRIPT MIGRATION

### CORE PRINCIPLE: STRICT TYPE SAFETY
**NEVER compromise on type safety. Every migration must achieve 100% TypeScript coverage with strict typing.**

#### MANDATORY MIGRATION RULES
1. **Strict TypeScript**: Use strict TypeScript configuration
2. **Complete Type Coverage**: Every variable, function, and component must be typed
3. **Interface Definitions**: Create comprehensive interfaces for all data structures
4. **Type Safety**: No 'any' types unless absolutely necessary
5. **Documentation**: Document all type definitions and their purposes

## üîç TYPESCRIPT MIGRATION CATEGORIES

### FILE MIGRATION
**REQUIRED MIGRATIONS:**

#### File Extensions
- [ ] **REQUIRED**: Change .js files to .ts
- [ ] **REQUIRED**: Change .jsx files to .tsx
- [ ] **REQUIRED**: Update import statements
- [ ] **REQUIRED**: Fix file references
- [ ] **REQUIRED**: Update build configuration

#### Basic Type Annotations
- [ ] **REQUIRED**: Add type annotations to all variables
- [ ] **REQUIRED**: Add type annotations to all function parameters
- [ ] **REQUIRED**: Add type annotations to all function return values
- [ ] **REQUIRED**: Add type annotations to all object properties
- [ ] **REQUIRED**: Add type annotations to all array elements

### INTERFACE DEFINITIONS
**REQUIRED MIGRATIONS:**

#### Component Props
- [ ] **REQUIRED**: Create interfaces for all component props
- [ ] **REQUIRED**: Define optional and required props
- [ ] **REQUIRED**: Add JSDoc comments for prop descriptions
- [ ] **REQUIRED**: Use generic types where appropriate
- [ ] **REQUIRED**: Extend base interfaces for common props

#### API Data Structures
- [ ] **REQUIRED**: Create interfaces for all API response data
- [ ] **REQUIRED**: Define request and response types
- [ ] **REQUIRED**: Add error type definitions
- [ ] **REQUIRED**: Create generic API response types
- [ ] **REQUIRED**: Define pagination and filtering types

#### State Management
- [ ] **REQUIRED**: Create interfaces for all state objects
- [ ] **REQUIRED**: Define action types for state updates
- [ ] **REQUIRED**: Create context type definitions
- [ ] **REQUIRED**: Define reducer types
- [ ] **REQUIRED**: Add state validation types

### HOOK MIGRATIONS
**REQUIRED MIGRATIONS:**

#### Custom Hooks
- [ ] **REQUIRED**: Add type annotations to all custom hooks
- [ ] **REQUIRED**: Define return types for all hooks
- [ ] **REQUIRED**: Add parameter types for all hook functions
- [ ] **REQUIRED**: Create generic types for reusable hooks
- [ ] **REQUIRED**: Add JSDoc comments for hook documentation

#### React Hooks
- [ ] **REQUIRED**: Add type annotations to useState calls
- [ ] **REQUIRED**: Add type annotations to useEffect dependencies
- [ ] **REQUIRED**: Add type annotations to useCallback functions
- [ ] **REQUIRED**: Add type annotations to useMemo functions
- [ ] **REQUIRED**: Add type annotations to useContext calls

### COMPONENT MIGRATIONS
**REQUIRED MIGRATIONS:**

#### Functional Components
- [ ] **REQUIRED**: Add type annotations to all functional components
- [ ] **REQUIRED**: Define prop interfaces for all components
- [ ] **REQUIRED**: Add generic types for reusable components
- [ ] **REQUIRED**: Add JSDoc comments for component documentation
- [ ] **REQUIRED**: Use React.FC or explicit return types

#### Class Components
- [ ] **REQUIRED**: Add type annotations to all class components
- [ ] **REQUIRED**: Define prop and state interfaces
- [ ] **REQUIRED**: Add type annotations to lifecycle methods
- [ ] **REQUIRED**: Add type annotations to event handlers
- [ ] **REQUIRED**: Add generic types for reusable components

### API MIGRATIONS
**REQUIRED MIGRATIONS:**

#### GraphQL Types
- [ ] **REQUIRED**: Generate TypeScript types from GraphQL schema
- [ ] **REQUIRED**: Create interfaces for all GraphQL queries
- [ ] **REQUIRED**: Define mutation and subscription types
- [ ] **REQUIRED**: Add error type definitions
- [ ] **REQUIRED**: Create generic GraphQL response types

#### REST API Types
- [ ] **REQUIRED**: Create interfaces for all REST API endpoints
- [ ] **REQUIRED**: Define request and response types
- [ ] **REQUIRED**: Add error handling types
- [ ] **REQUIRED**: Create generic API client types
- [ ] **REQUIRED**: Define authentication types

## üîß MIGRATION METHODOLOGY

### PHASE 1: CONFIGURATION SETUP
**REQUIRED ACTIONS:**
1. **Update tsconfig.json**: Configure strict TypeScript settings
2. **Install Dependencies**: Install required TypeScript packages
3. **Update Build Scripts**: Modify build scripts for TypeScript
4. **Configure Paths**: Set up path aliases and module resolution
5. **Test Configuration**: Verify TypeScript configuration works

### PHASE 2: FILE MIGRATION
**REQUIRED ACTIONS:**
1. **Change Extensions**: Convert .js/.jsx files to .ts/.tsx
2. **Fix Imports**: Update import statements for TypeScript
3. **Add Basic Types**: Add type annotations to all variables
4. **Fix Compilation**: Resolve TypeScript compilation errors
5. **Test Build**: Verify build process works

### PHASE 3: INTERFACE CREATION
**REQUIRED ACTIONS:**
1. **Create Interfaces**: Define interfaces for all data structures
2. **Add JSDoc**: Add documentation for all interfaces
3. **Use Generics**: Create generic types where appropriate
4. **Extend Interfaces**: Use interface inheritance for common patterns
5. **Test Interfaces**: Verify interfaces work correctly

### PHASE 4: COMPONENT MIGRATION
**REQUIRED ACTIONS:**
1. **Migrate Components**: Convert all components to TypeScript
2. **Add Prop Types**: Define prop interfaces for all components
3. **Add Hook Types**: Add type annotations to all hooks
4. **Fix Event Handlers**: Add proper event handler types
5. **Test Components**: Verify all components work correctly

### PHASE 5: API MIGRATION
**REQUIRED ACTIONS:**
1. **Migrate API Calls**: Convert all API calls to TypeScript
2. **Add Response Types**: Define response interfaces
3. **Add Error Types**: Create error handling types
4. **Add Request Types**: Define request interfaces
5. **Test APIs**: Verify all API calls work correctly

## üö´ COMMON MIGRATION PITFALLS

### TYPE PITFALLS
- **Any Types**: Avoid using 'any' unless absolutely necessary
- **Implicit Any**: Enable strict mode to catch implicit any
- **Type Assertions**: Use type assertions carefully
- **Type Guards**: Use type guards for runtime type checking
- **Generic Constraints**: Use proper generic constraints

### INTERFACE PITFALLS
- **Missing Properties**: Ensure all required properties are defined
- **Optional Properties**: Use optional properties correctly
- **Index Signatures**: Use index signatures for dynamic properties
- **Union Types**: Use union types for multiple possible types
- **Intersection Types**: Use intersection types for combining interfaces

### COMPONENT PITFALLS
- **Prop Types**: Ensure all props are properly typed
- **Event Handlers**: Use proper event handler types
- **Ref Types**: Use proper ref types for DOM elements
- **Children Types**: Use proper children types
- **Generic Components**: Use generics for reusable components

## üîß MIGRATION TOOLS & COMMANDS

### MIGRATION TOOLS
```bash
# Install TypeScript
npm install -D typescript @types/react @types/node

# TypeScript compilation
npx tsc --noEmit

# Type checking
npx tsc --noEmit --strict

# Build process
npm run build
```

### TESTING TOOLS
```bash
# TypeScript compilation
npx tsc --noEmit

# Build testing
npm run build

# Development server
npm run dev
```

### VERIFICATION TOOLS
```bash
# Type coverage
npx type-coverage

# Type checking
npx tsc --noEmit --strict --noImplicitAny

# Build verification
npm run build && npm run start
```

## ‚úÖ SUCCESS CRITERIA

### MIGRATION SUCCESS CHECKLIST
**Every TypeScript migration must meet these standards:**

- [ ] **File Migration**: All files converted to TypeScript
- [ ] **Type Coverage**: 100% type coverage achieved
- [ ] **Interface Definitions**: All data structures have interfaces
- [ ] **Type Safety**: No 'any' types used unnecessarily
- [ ] **Compilation**: TypeScript compilation succeeds
- [ ] **Build Process**: Build process works correctly
- [ ] **Runtime**: No runtime errors
- [ ] **Documentation**: All types are documented

### MIGRATION SUCCESS METRICS
- **Type Coverage**: 100% type coverage
- **Compilation**: Zero TypeScript errors
- **Type Safety**: No 'any' types used
- **Performance**: No performance regression
- **Maintainability**: Code is more maintainable

## üîÑ CONTINUOUS IMPROVEMENT

### MIGRATION LEARNING CAPTURE
**After each migration:**
1. **Document Migration Process**: Record what worked and what didn't
2. **Identify Common Issues**: Find patterns in migration problems
3. **Update Migration Guide**: Refine migration procedures
4. **Improve Tools**: Enhance migration tools and scripts
5. **Share Learnings**: Update team with migration insights

### MIGRATION AUTOMATION
- **Migration Scripts**: Create automated migration scripts
- **Type Generation**: Automate type generation from APIs
- **Testing Automation**: Implement automated type testing
- **Performance Monitoring**: Monitor performance during migration

**Remember**: You are the guardian of type safety. Every migration must achieve 100% TypeScript coverage with strict typing. Your expertise ensures code quality and maintainability.