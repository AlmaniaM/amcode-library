# Debug Command

## Purpose
Systematically debug and troubleshoot issues using evidence-based investigation, root cause analysis, and systematic problem-solving approaches that align with Cursor's recommended debugging methodologies.

## When to Use
- **Bug Investigation**: When investigating reported bugs or issues
- **Performance Debugging**: When debugging performance problems or bottlenecks
- **Integration Issues**: When debugging integration problems or API issues
- **User Experience Issues**: When debugging user interface or experience problems
- **System Failures**: When debugging system failures or crashes
- **Data Issues**: When debugging data corruption or validation problems

## Command Structure

### Phase 1: Issue Analysis & Context Gathering
**AUTONOMOUS PRINCIPAL ENGINEER DOCTRINE**: Begin with comprehensive understanding of the issue and its context.

#### Issue Analysis
- **Problem Definition**: Clearly define the problem and its symptoms
- **Impact Assessment**: Assess the impact and severity of the issue
- **Scope Definition**: Define the scope of the debugging effort
- **Stakeholder Analysis**: Identify who is affected and who needs to be informed
- **Timeline Assessment**: Assess urgency and required resolution timeline

#### Context Gathering
- **Environment Analysis**: Analyze the environment where the issue occurs
- **Configuration Review**: Review relevant configuration and settings
- **Log Analysis**: Analyze logs and error messages
- **User Reports**: Review user reports and feedback
- **Historical Analysis**: Analyze similar issues and their resolutions

### Phase 2: Evidence Collection & Investigation
**Evidence-Based Approach**: Collect comprehensive evidence to understand the issue.

#### Evidence Collection
- **Log Collection**: Collect relevant logs and error messages
- **System State**: Capture system state and configuration
- **User Data**: Collect user data and input that triggers the issue
- **Performance Data**: Collect performance metrics and monitoring data
- **Network Data**: Collect network traffic and communication data

#### Investigation Techniques
- **Reproduction**: Attempt to reproduce the issue consistently
- **Isolation**: Isolate the issue to specific components or modules
- **Comparison**: Compare working and non-working scenarios
- **Timeline Analysis**: Analyze the timeline of events leading to the issue
- **Dependency Analysis**: Analyze dependencies and their impact on the issue

### Phase 3: Root Cause Analysis
**Systematic Investigation**: Use systematic approaches to identify the root cause.

#### Hypothesis Formation
- **Initial Hypotheses**: Form initial hypotheses about the root cause
- **Evidence Evaluation**: Evaluate evidence for and against each hypothesis
- **Hypothesis Refinement**: Refine hypotheses based on new evidence
- **Alternative Explanations**: Consider alternative explanations and scenarios
- **Confidence Assessment**: Assess confidence in each hypothesis

#### Root Cause Identification
- **Evidence Correlation**: Correlate evidence to identify patterns
- **Timeline Reconstruction**: Reconstruct the timeline of events
- **Dependency Analysis**: Analyze how dependencies contribute to the issue
- **System Interaction Analysis**: Analyze how system components interact
- **Root Cause Validation**: Validate the identified root cause

### Phase 4: Solution Design & Implementation
**Systematic Resolution**: Design and implement solutions to address the root cause.

#### Solution Design
- **Solution Options**: Identify multiple solution options
- **Impact Analysis**: Analyze the impact of each solution option
- **Risk Assessment**: Assess risks associated with each solution
- **Implementation Complexity**: Assess implementation complexity and effort
- **Solution Selection**: Select the best solution based on analysis

#### Solution Implementation
- **Implementation Planning**: Plan the implementation of the selected solution
- **Testing Strategy**: Plan testing to validate the solution
- **Rollback Planning**: Plan rollback procedures if the solution fails
- **Monitoring Strategy**: Plan monitoring to ensure the solution works
- **Documentation**: Document the solution and implementation process

### Phase 5: Validation & Testing
**Comprehensive Validation**: Validate that the solution resolves the issue.

#### Solution Validation
- **Reproduction Testing**: Test that the issue no longer reproduces
- **Regression Testing**: Test that the solution doesn't break existing functionality
- **Performance Testing**: Test that the solution doesn't impact performance
- **Integration Testing**: Test that the solution works with other components
- **User Acceptance Testing**: Test that the solution meets user expectations

#### Monitoring & Verification
- **Continuous Monitoring**: Monitor the system to ensure the solution works
- **Performance Monitoring**: Monitor performance to ensure no degradation
- **Error Monitoring**: Monitor for new errors or issues
- **User Feedback**: Collect user feedback on the solution
- **Long-term Validation**: Validate the solution over time

### Phase 6: Documentation & Knowledge Transfer
**Knowledge Management**: Document the debugging process and solution.

#### Documentation
- **Issue Documentation**: Document the issue and its symptoms
- **Root Cause Documentation**: Document the root cause and analysis
- **Solution Documentation**: Document the solution and implementation
- **Process Documentation**: Document the debugging process and methodology
- **Lessons Learned**: Document lessons learned and best practices

#### Knowledge Transfer
- **Team Knowledge**: Transfer knowledge to team members
- **Stakeholder Communication**: Communicate the solution to stakeholders
- **Training Materials**: Create training materials for similar issues
- **Process Improvement**: Improve debugging processes based on experience
- **Prevention Strategies**: Develop strategies to prevent similar issues

## Debugging Methodologies

### Systematic Debugging
- **Step-by-Step Approach**: Follow a systematic step-by-step approach
- **Evidence-Based**: Base decisions on evidence and data
- **Documentation-Heavy**: Document all steps and findings
- **Process-Driven**: Follow established debugging processes
- **Quality-Focused**: Focus on quality and thoroughness

### Agile Debugging
- **Rapid Iteration**: Use rapid iteration and quick fixes
- **User-Centric**: Focus on user impact and experience
- **Collaborative**: Work closely with team members and stakeholders
- **Adaptive**: Adapt approach based on findings and feedback
- **Learning-Oriented**: Learn from each debugging experience

### Hybrid Debugging
- **Adaptive Approach**: Combine methodologies based on issue complexity
- **Risk-Based**: Adjust approach based on risk assessment
- **Stakeholder-Driven**: Adapt approach to stakeholder needs
- **Technology-Adaptive**: Adjust approach based on technology stack
- **Context-Sensitive**: Adapt approach to issue context

## Technology-Specific Debugging

### Frontend Debugging
- **Browser DevTools**: Use browser developer tools for debugging
- **Component Debugging**: Debug React, Vue, Angular, or other components
- **State Debugging**: Debug application state and data flow
- **Performance Debugging**: Debug frontend performance issues
- **User Interface Debugging**: Debug user interface and experience issues

### Backend Debugging
- **API Debugging**: Debug API endpoints and responses
- **Database Debugging**: Debug database operations and queries
- **Service Debugging**: Debug microservices and service interactions
- **Performance Debugging**: Debug backend performance issues
- **Security Debugging**: Debug security vulnerabilities and issues

### Full-Stack Debugging
- **End-to-End Debugging**: Debug complete user workflows
- **Integration Debugging**: Debug frontend-backend integration
- **System Debugging**: Debug complete system functionality
- **Performance Debugging**: Debug overall system performance
- **Security Debugging**: Debug overall system security

## Debugging Tools & Techniques

### Debugging Tools
- **IDE Debuggers**: Visual Studio Code, IntelliJ, Eclipse, Xcode
- **Browser DevTools**: Chrome DevTools, Firefox DevTools, Safari DevTools
- **API Testing**: Postman, Insomnia, curl, HTTPie
- **Database Tools**: pgAdmin, MySQL Workbench, MongoDB Compass
- **Monitoring Tools**: New Relic, DataDog, Splunk, ELK Stack

### Debugging Techniques
- **Logging**: Add comprehensive logging to understand execution flow
- **Breakpoints**: Use breakpoints to pause execution and inspect state
- **Step-through Debugging**: Step through code line by line
- **Variable Inspection**: Inspect variable values and state
- **Call Stack Analysis**: Analyze call stack to understand execution path

## Debugging Outputs

### Debugging Artifacts
- **Issue Reports**: Detailed issue reports and analysis
- **Root Cause Analysis**: Comprehensive root cause analysis
- **Solution Documentation**: Complete solution documentation
- **Process Documentation**: Debugging process and methodology documentation
- **Lessons Learned**: Lessons learned and best practices

### Quality Metrics
- **Resolution Time**: Time to resolve issues
- **Root Cause Accuracy**: Accuracy of root cause identification
- **Solution Effectiveness**: Effectiveness of implemented solutions
- **Prevention Success**: Success in preventing similar issues
- **Knowledge Transfer**: Effectiveness of knowledge transfer

### Recommendations
- **Process Improvements**: Recommendations for improving debugging processes
- **Tool Recommendations**: Recommendations for debugging tools and techniques
- **Prevention Strategies**: Strategies for preventing similar issues
- **Training Recommendations**: Recommendations for team training and development
- **System Improvements**: Recommendations for system improvements

## Usage Examples

### Bug Investigation
```
/debug
Investigate the user authentication issue where users are being logged out unexpectedly, including root cause analysis and solution implementation.
```

### Performance Debugging
```
/debug
Debug the performance issue where the application becomes slow after processing large datasets, including bottleneck identification and optimization.
```

### Integration Debugging
```
/debug
Debug the integration issue between our frontend and the payment API, including API communication problems and data flow issues.
```

### System Failure Debugging
```
/debug
Debug the system crash that occurred during peak usage, including error analysis, root cause identification, and system recovery.
```

## Success Criteria

### Debugging Quality
- **Root Cause Accuracy**: Correctly identifies the root cause of issues
- **Solution Effectiveness**: Implements effective solutions that resolve issues
- **Process Efficiency**: Uses efficient debugging processes and techniques
- **Documentation Quality**: Provides comprehensive documentation and knowledge transfer
- **Prevention Success**: Successfully prevents similar issues from occurring

### Resolution Success
- **Issue Resolution**: Successfully resolves the reported issue
- **System Stability**: Maintains or improves system stability
- **Performance Impact**: Minimizes negative impact on system performance
- **User Experience**: Maintains or improves user experience
- **Team Knowledge**: Effectively transfers knowledge to team members

## Integration with Other Commands

### Pre-Debugging
- Use with `/understand` to understand the issue context before debugging
- Use with `/analyze-code-deep` to understand code before debugging
- Use with `/analyze-project-deep` to understand system architecture

### During Debugging
- Use with `/test` to test debugging solutions and fixes
- Use with `/implement` to implement debugging solutions
- Use with `/refactor` to improve code based on debugging findings

### Post-Debugging
- Use with `/retro` to learn from debugging experience
- Use with `/plan` to plan prevention strategies
- Use with `/analyze-performance` to validate performance improvements

**Remember**: The `/debug` command is your systematic problem-solving engine. Use it to debug issues using evidence-based investigation, root cause analysis, and systematic resolution approaches. The command adapts to your specific needs and provides the level of debugging detail appropriate for your context.
