# Autonomous Agent Framework Overview

## Overview

Complete overview of the Autonomous Principal Engineer framework implemented in this workspace. Shows available commands, rules, and how to use them effectively.

## Framework Philosophy

This framework elevates AI from a simple command executor to an **Autonomous Principal Engineer** based on five core principles:

1. **Research-First, Always:** Never act on assumption - investigate current system state first
2. **Extreme Ownership:** Responsibility extends beyond immediate task to entire system health
3. **Autonomous Problem-Solving:** Self-sufficient with exhaustive research before escalation
4. **Unyielding Precision & Safety:** Treat environment with utmost respect and safety
5. **Metacognitive Self-Improvement:** Learn and improve through systematic reflection

## Available Commands

### Core Operational Commands

#### `/do` - Standard Development Tasks

**Purpose:** Execute any development task using the full 5-phase operational doctrine
**Use for:** Building features, refactoring code, implementing components
**Example:** `/do create a new Angular component for products`

#### `/refresh` - Root Cause Analysis & Deep Diagnostics

**Purpose:** Systematic diagnosis when simpler attempts have failed
**Use for:** Persistent bugs, intermittent failures, complex issues
**Example:** `/refresh Authentication keeps failing intermittently`

#### `/retro` - Retrospective & Evolution

**Purpose:** Conduct session retrospective and evolve the operational doctrine
**Use for:** End of significant sessions to capture learnings
**Example:** `/retro`

#### `/framework` - This Overview

**Purpose:** Display complete framework documentation and usage
**Use for:** Understanding available tools and methods

### Feature Development Commands

#### `/feature-design` - Feature Design Protocol

**Purpose:** Comprehensive feature design using systematic analysis, requirements gathering, and visual design presentation
**Use for:** Creating complete design specifications for new features
**Example:** `/feature-design Add user profile editing functionality to @src/components/UserProfileComponent`

#### `/feature-implement` - Feature Implementation Protocol

**Purpose:** Systematic feature implementation based on existing design specification
**Use for:** Implementing features following approved design specifications
**Example:** `/feature-implement using design from @.cursor/context/feature-design-user-profile.json`

### Analysis Commands

#### `/analyze` - Deep Analysis Protocol

**Purpose:** Comprehensive analysis of project areas or specific code targets
**Use for:** Understanding system architecture, code patterns, dependencies
**Example:** `/analyze Review the complete monorepo structure`

#### `/analyze-code` - Deep Code Analysis Protocol

**Purpose:** Comprehensive analysis of specific code files, classes, or components
**Use for:** Understanding code structure, patterns, business logic
**Example:** `/analyze-code Analyze the UserService class`

#### `/analyze-project` - Deep Project Analysis Protocol

**Purpose:** Comprehensive analysis of project-level concerns and architecture
**Use for:** Understanding technology stack, monorepo structure, build systems
**Example:** `/analyze-project Analyze the complete project architecture`

### Shallow Analysis Commands (Context-Efficient)

#### `/analyze-code-shallow` - Shallow Code Analysis Protocol

**Purpose:** Focused analysis of code files with minimal context usage
**Use for:** Quick code insights, essential pattern detection
**Example:** `/analyze-code-shallow Analyze the UserService class quickly`

#### `/analyze-project-shallow` - Shallow Project Analysis Protocol

**Purpose:** Focused analysis of project concerns with minimal context usage
**Use for:** Quick project insights, essential architectural understanding
**Example:** `/analyze-project-shallow Get quick project overview`

### Bug Analysis Commands

#### `/analyze-bug-fix-deep` - Deep Bug Analysis Protocol

**Purpose:** Comprehensive bug analysis using systematic root cause analysis with evidence-based investigation
**Use for:** Thorough bug understanding with complete system analysis
**Example:** `/analyze-bug-fix-deep Analyze the UserService.ts file for authentication issues`

#### `/analyze-bug-fix-shallow` - Shallow Bug Analysis Protocol

**Purpose:** Focused bug analysis using streamlined reconnaissance and essential pattern detection
**Use for:** Quick bug insights with minimal context usage
**Example:** `/analyze-bug-fix-shallow Analyze the UserService.ts file for authentication issues`

#### `/analyze-bug-with-graph-deep` - Deep Bug Analysis with Execution Graph

**Purpose:** Comprehensive bug analysis with detailed execution graph visualization
**Use for:** Visual bug analysis with complete system flow understanding
**Example:** `/analyze-bug-with-graph-deep Analyze the UserService.ts file for authentication issues`

#### `/analyze-bug-with-graph-shallow` - Shallow Bug Analysis with Execution Graph

**Purpose:** Focused bug analysis with execution graph visualization
**Use for:** Quick visual bug analysis with minimal context usage
**Example:** `/analyze-bug-with-graph-shallow Analyze the UserService.ts file for authentication issues`

### Utility Commands

#### `/save-context` - Save Context Command

**Purpose:** Save current LLM context with session status and progress
**Use for:** Maintaining continuity across sessions, preserving work context
**Example:** `/save-context`

## Active Rules

### Always Applied Rules (2 rules)

- **Senior Frontend Architect Doctrine:** Angular/TypeScript expertise with clean code principles and autonomous principal engineering authority
- **Professional Communication:** Avoid sycophantic language, maintain technical focus, and use radical conciseness for maximum information density

### Context-Specific Rules (13 rules - Fetch When Needed)

- **Code Pattern Validation:** Ensures code patterns are compatible with framework versions
- **Code Pattern Validation (Concise):** Concise version of code pattern validation
- **Dependency Research Protocol:** Ensures thorough research before dependency changes
- **Dependency Research Protocol (Concise):** Concise version of dependency research
- **Error Recovery Protocol:** Systematic approach to recovering from failures
- **Error Recovery Protocol (Concise):** Concise version of error recovery
- **Incremental Verification:** Ensures each step succeeds before proceeding
- **Incremental Verification (Concise):** Concise version of incremental verification
- **Multi-Layer Verification:** Ensures comprehensive verification across all system layers
- **Multi-Layer Verification (Concise):** Concise version of multi-layer verification
- **Pre-Execution Validation:** Ensures all prerequisites are met before execution
- **Pre-Execution Validation (Concise):** Concise version of pre-execution validation
- **UX Specialist Doctrine:** Design system expertise and UX pattern mastery since 2010

## Workflow Patterns

### Standard Development Workflow (`/do`)

1. **Phase 0:** Reconnaissance & Mental Modeling (Read-Only)
2. **Phase 1:** Planning & Strategy
3. **Phase 2:** Execution & Implementation
4. **Phase 3:** Verification & Autonomous Correction
5. **Phase 4:** Mandatory Zero-Trust Self-Audit
6. **Phase 5:** Final Report & Verdict

### Deep Diagnostic Workflow (`/refresh`)

1. **Phase 0:** Reconnaissance & State Baseline
2. **Phase 1:** Isolate the Anomaly
3. **Phase 2:** Root Cause Analysis (RCA)
4. **Phase 3:** Remediation
5. **Phase 4:** Verification & Regression Guard
6. **Phase 5:** Zero-Trust Self-Audit
7. **Phase 6:** Final Report & Verdict

### Analysis Workflows

- **Deep Analysis:** `/analyze`, `/analyze-code`, `/analyze-project` - Comprehensive understanding
- **Shallow Analysis:** `/analyze-code-shallow`, `/analyze-project-shallow` - Quick insights
- **Bug Analysis:** `/analyze-bug-fix-deep`, `/analyze-bug-fix-shallow` - Bug investigation
- **Visual Bug Analysis:** `/analyze-bug-with-graph-deep`, `/analyze-bug-with-graph-shallow` - Bug analysis with execution graphs

### Feature Development Workflows

- **Feature Design:** `/feature-design` - Complete feature design with requirements gathering and visual presentation
- **Feature Implementation:** `/feature-implement` - Systematic implementation based on design specifications

### Evolution Workflow (`/retro`)

1. **Phase 0:** Session Analysis (Internal Reflection)
2. **Phase 1:** Lesson Distillation & Abstraction
3. **Phase 2:** Doctrine Integration
4. **Phase 3:** Final Report

## Status Markers

Throughout all workflows, these markers track progress:

- `‚úÖ` Objective completed successfully
- `‚ö†Ô∏è` Recoverable issue encountered and fixed autonomously
- `üöß` Blocked; awaiting input or resource

## Frontend-Specific Excellence

This framework is optimized for Angular monorepo development with:

- Component and service impact analysis and dependency mapping
- Performance considerations (bundle size, lazy loading)
- TypeScript compliance and type safety
- Accessibility standards (semantic HTML, ARIA)
- Clean architecture patterns and Angular best practices

## Rule Management

### Always Applied (2 rules)

- **Core Identity:** Senior Frontend Architect expertise
- **Communication:** Professional, non-sycophantic communication
- **Safety:** Pre-execution validation and error recovery protocols

### Context-Specific (13 rules)

- **Specialized Protocols:** Code patterns, dependencies, verification layers
- **UX Expertise:** Design systems and user experience patterns
- **Communication Styles:** Concise communication when needed

## Usage Tips

### Command Selection

1. **Start with `/do`** for most development tasks
2. **Use `/refresh`** when standard debugging hasn't worked
3. **Use `/feature-design`** for comprehensive feature design and requirements gathering
4. **Use `/feature-implement`** for systematic implementation based on design specifications
5. **Use `/analyze-*`** for understanding codebase or specific components
6. **Use `/analyze-*-shallow`** for quick insights with minimal context
7. **Use `/analyze-bug-*`** for systematic bug investigation and root cause analysis
8. **Use `/analyze-bug-with-graph-*`** for visual bug analysis with execution graphs
9. **Use `/save-context`** to preserve session state
10. **End sessions with `/retro`** to capture learnings and improve

### Rule Usage

1. **Always Applied Rules:** Automatically active, no action needed
2. **Context-Specific Rules:** Fetch when needed for specialized tasks
3. **Concise Versions:** Use concise rules for maximum information density
4. **UX Specialist:** Fetch for UI/UX design tasks
5. **Validation Protocols:** Fetch for code patterns, dependencies, and verification tasks

### Best Practices

1. **Trust the process** - each phase is designed for systematic excellence
2. **Use shallow analysis** for quick insights, deep analysis for comprehensive understanding
3. **Use visual bug analysis** for complex debugging with execution graphs
4. **Design before implementing** - use `/feature-design` before `/feature-implement`
5. **Reference `/framework`** when you need guidance on available tools
6. **Save context regularly** to maintain continuity across sessions
7. **End sessions with `/retro`** to capture learnings and improve the framework

The framework ensures every action is deliberate, verifiable, and aligned with senior engineering best practices.
